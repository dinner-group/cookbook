As you should know for the PLUMED tutorials linked earlier, PLUMED is a supremely versatile tool that can be used to both extract CVs from existing trajectories and calculate CVs/bias simulations on the fly. This makes it our primary tool to run sampling algorithms like Adiabatic-Bias Molecular Dynamics (ABMD), umbrella sampling, metadynamics, NEUS, and more. The previously linked tutorials, along with all of the [tutorials available ](https://www.plumed.org/doc-v2.5/user-doc/html/tutorials.html) will do a better of introducing you to using PLUMED than I will be able to recreate here. PLUMED is best learned just by doing. This page is meant as a collection of tips and tricks, constantly updated, as some of the implementation of PLUMED algorithms can be a little bit wonky. If you find yourself with questions you cannot find the answers to (either online or from other grad students), feel free to post in the[PLUMED google group](https://groups.google.com/g/plumed-users) or the[GROMACS forum](https://gromacs.bioexcel.eu/). Both are great resources for questions you cannot find the answers to otherwise. Just be sure to read the rules before posting (and read to see if your question has been asked before), and be very descriptive in your question. 

WHOLEMOLECULES and Periodic Boundary Conditions
-----------------------------------------------

Periodic boundary conditions give PLUMED a lot of headaches, and can be the cause of many strange errors. One common manifestation is the presence of odd, aphysical discontinuities in your CVS, that seemingly do not match with your trajectories. There is even a [wiki article about it](/display/thecookbook/%5BMD%5D+Strange+discontinuities+in+distances+or+RMSDs+in+my+trajectories). That article has a fairly in-depth treatment of all of the different options for dealing with PBCs, focusing primarily on the use of both WHOLEMOLECULES and the NOPBC flag. It is worth going through that article - this is probably the most common PLUMED error out there, in my experience. 

Defining Groups with an Index File
----------------------------------

For some CVs, including [COORDINATION](https://www.plumed.org/doc-v2.5/user-doc/html/_c_o_o_r_d_i_n_a_t_i_o_n.html) (which counts the number of contacts a certain set of residues makes), it is useful to define [groups](https://www.plumed.org/doc-v2.5/user-doc/html/_g_r_o_u_p.html) of atoms that the CV will actually measure. T=You can either do these manually, by feeding in a comma separated list of atom ids (found in your PDB file and indexed starting at 1), or by using a .ndx file. You should be familiar with these files from your thermostatting step. You can modify your .ndx file by appending a new group to the end of the file, following the syntax of the already-existing file. The spaces and pagebreaks around the group name **do** matter, while the pagebreaks between atom ids themselves are only there for readability. The file should end with a newline. To get the space-separated list of atom ids, you can either use bash (by running a grep command on your pdb file, for example), or you can use VMD (example seen in [VMD as an Analysis Tool](/display/thecookbook/VMD+as+an+Analysis+Tool)). You can then import a group from your index file into your plumed file by including a command like the following. 

    #Define all the atoms in phenol #4 in the insulin hexamer crystal structure
    iph4: GROUP NDX_FILE=``/pylon5/mc5fphp/anto/essentials/hex/index``.ndx NDX_GROUP=NOH_IPH4

RMSDs
-----

Sometimes, you may want to calculate some type of distance of your current structure to a reference structure. The RMSD is the most straightforward way to do this. **A word of caution**: while RMSDs are sometimes an intuitive choice for a CV, they can also be less than informative, and often are quite bad variables to bias upon. There are many ways for RMSDs to increase or decrease, and only sometimes are those changes are simple and easily visible when inspecting your trajectories. Many disparate protein conformations can have a particular RMSD value - you are inherently losing some structural information when you define such a broad CV. Because it is so broad, and because it is unbounded (as in the RMSD can increase arbitrarily as your molecule deviates from the reference structure), biases placed on RMSDs, especially for large molecules/proteins, can produce some oddly pathological results. Also, to be clear: RMSD is not manifestly a measure of disorder. It is a distance from a reference structure. Sometimes, your RMSD will increase even as your protein adopts a more ordered conformation. And finally, most RMSD algorithms (excluding DRMSD, which we will talk about later) rely on some fitting algorithm that first fits your current structure to the reference structure, and then calculates the RMSD. This fitting can be touchy, and sometimes misleading, as fitting a disordered protein to an ordered structure is non-obvious. All of this is to say that RMSDs are not perfect, and often times a physical CV (an angle, dihedral, alpha helix content), or even another general CV that is bounded (number of contacts, % native contacts, etc), is a better choice. 

That being said, sometimes you still will decide a RMSD is best. In that case, if you use the [RMSD](https://www.plumed.org/doc-v2.5/user-doc/html/_r_m_s_d.html) command, you should always use the TYPE=OPTIMAL fitting procedure. It is often times a good idea to measure the RMSD of backbone atoms, to reduce overall noise. Other times, you just want the RMSD of a particular section, and not the overall molecule. To do this, you will need to generate a pdb file for just the selection of atoms you are calculating the RMSD against - you can do this with the appropriate grep command on your original PDB file. A few notes on the format of this PDB file: the last two columns should always be set to 1.0 - the default is normally 0.0. You will need to change these to get the expected behavior. You will also need to make sure to include an END statement at the end of said PDB file. **Always** check your RMSD trajectory and compare it to your actual trajectory in VMD - you should be able to understand any RMSD fluctuations by looking at the structure. If you see sharp discontinuities unexplained by your atomic trajectory, that is likely a bug in the RMSD fitting algorithm. You can try to pre-process your data by aligning the structures using GROMACS (using [trjconv ](http://manual.gromacs.org/documentation/5.1/onlinehelp/gmx-trjconv.html) \-center -pbc mol, and then the -fit rot+trans flag) and then using PLUMED [driver](https://www.plumed.org/doc-v2.5/user-doc/html/driver.html) to measure the RMSD of this pre-processed trajectory. If his doesn't fix the problem, it could be that your selection is too large to reliably fit. Try to decrease the size of your selection, by only fitting on alpha carbons for example. If that doesn't work, then you might have ran up against the limitations of PLUMED's RMSD algorithm. 

You can always use [DRMSD](https://www.plumed.org/doc-v2.5/user-doc/html/_d_r_m_s_d.html) instead! Instead of fitting structures and calculating a distance, it first calculates all the pairwise distances in your both your reference atom selection and current structure, and then calculates the "distance in distance space" from your current structure to the reference structure. This makes it unnecessary to run an initial fit, as you are not actually finding distances between atoms in one frame compared to another frame. Instead, you are calculating the inter-atom distances between frame - these distances do not change with a standard translational/rotational fit. All of the same caveats still apply, but I have found the DRMSD to be a little more reliable than the vanilla RMSD. 

You can also do most of these RMSD measurements by using [VMD as an Analysis Tool](/display/thecookbook/VMD+as+an+Analysis+Tool), if you so choose. 

Contacts vs. Distances
----------------------

When trying to determine how far apart two particular atoms are, the most straightforward approach is just to measure their distance from each other. Distances have the distinct advantage of being easily physically interpretable, which is good. However, distances are unbounded: similar to what was previously discussed with RMSDs, distances can arbitrarily increase. Depending on what you are doing, this might be a good thing, or it might be a bad thing. For example, if you are trying to measure if two atoms are interacting via Van Der Waals forces, a interatomic distance of 1 nm is functionally the same thing as a distance of 5 nm. Furthermore, when you are biasing a simulation (either with a static potential, like in umbrella sampling, or with a moving potential, as in steered molecular dynamics), sometimes applying these biases to distances can provide fairly poor control of the system. This will be dependent on your system and your force constants you use, so you should by all means investigate to see if this is true. However, it has been my experience that some biasing on some contact measure often times provides better control of the system. For example, you could do this by explicitly transforming a few distances to make them smoothly vary between 0 (no longer interacting) and 1 (strongly interacting).  This can be done with the [CONTACTMAP](https://www.plumed.org/doc-v2.5/user-doc/html/_c_o_n_t_a_c_t_m_a_p.html) function - see Adam's [insulin dimer paper](https://pubs.acs.org/doi/10.1021/acs.jpcb.0c03521) for an application of this. You could also count the total number of contacts between specific interacting sections of (a) protein(s) using COORDINATION. Again, you should explore for yourself to find what works best for your system. 

Biasing
-------

In this group, the most common ways to apply biases to your system have been by using [RESTRAINT](https://www.plumed.org/doc-v2.5/user-doc/html/_r_e_s_t_r_a_i_n_t.html), [MOVINGRESTRAINT](https://www.plumed.org/doc-v2.5/user-doc/html/_m_o_v_i_n_g_r_e_s_t_r_a_i_n_t.html), or [ABMD](https://www.plumed.org/doc-v2.5/user-doc/html/_a_b_m_d.html) (although you should certainly explore the other biasing options available to you). The RESTRAINT command just throws up a harmonic bias at a particular point in CV space, which you can specify. This is useful for something like umbrella sampling, where you want to use these harmonic restraints to fully cover some CV space with sampling. MOVINGRESTRAINT and ABMD both correspond to driving the system in some way, as they are time-dependent. The typical MOVINGRESTRAINT command corresponds to constant velocity Steered Molecular Dynamics (SMD), where you throw up an initial harmonic bias at a location of your choosing, and then move that restraint (at a constant velocity) until it ends at some other location some time later, hopefully dragging your overall system along with it. ABMD is a similar concept, except it operates with a ratchet-and-pawl like mechanism. You can specify point in CV space where you want you system to move to, and ABMD will take advantage of equilibrium fluctuations to get you there. Whenever such a fluctuation takes you closer toward your target in CV space, the algorithm will throw up a half harmonic potential, discouraging the system from moving backward, farther away from your target. Both SMD and ABMD help you explore CV space. ABMD tends to be more gentle, decreasing the probability of giving you aphysical, high-energy structures. For this reason, it is my preferred method of driving, particularly for initializing further simulations, like for DGA or Umbrella Sampling. However, ABMD is much less reliable at actually driving you exactly here you want to go, especially when compared to SMD. It will normally get you nearby where you want to go, although even that isn't guaranteed. To get around this, you can launch a large set of ABMD simulation to drive to to many different areas of CV space, and then choose structures to initialize further simulations by comparing to that entire database. SMD, in contrast, is better suited to driving the system to a specific place, meaning you can use the output structure from one SMD simulation to initialize a further simulation. Feel free to check out Adam's [insulin dimer paper](https://pubs.acs.org/doi/10.1021/acs.jpcb.0c03521) or John's [trp-cage paper](https://pubs.acs.org/doi/abs/10.1021/acs.jctc.0c00933) for a more in-depth treatment of this.

Regardless, whenever you bias your system, there are a few parameters to consider. First, you need to choose an appropriate force constant. Too weak, and your bias won't actually do anything. Too strong, and you will either too tightly control your system, leading to very odd structures, or you will actually make your system blow up. This error is often times signaled by your simulation crashing with a LINCS error, saying that one or more bonds/angles increased in distance/rotated too much in one step. Basically, your forces were too strong, and your system exploded. The force constant you will need will depend both on your system and on the identity of the CV you are measuring. You should do some exploration to find the force constants that actually provide control for your system and choice of variable(s). As a general rule of thumb, you want the weakest bias you can apply while still providing reasonable control of your system. Beyond just the force constant, you need to make sure that the location of these biases make sense. For example, if you throw up a bias with a relatively weak force constant on a particular distance to try to restrain it to around 0.4 nm, but your system currently has an distance of 5.5 nm, the actual force felt by your system will be very large. You want to make sure that when you first apply your bias, you are not shocking the system. To measure this, you can use PLUMED to print out both the bias and squared force exerted by your applied potential, and make sure you aren't exposing the system to a ridiculous stress. It is extraordinarily important that you are looking at your trajectories with biased simulations, to make sure that your applied bias isn't making your system do something you don't want it to. Overall, biasing is a very powerful tool, but one you need to ensure is behaving correctly.